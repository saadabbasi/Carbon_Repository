#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include "uart.h"
#include "xitoa.h"
#include "ff.h"
#include "diskio.h"
#include "rtc.h"
#include "sed1335.h"
#include "25LC512.h"
#include "constants.h"
#include "SPIController.h"
#include "CPLD_API.h"
#include "CheckerAPI.h"
#include "display.h"

#define bit_get(p,m) ((p) & (m))
#define bit_set(p,m) ((p) |= (m))
#define bit_clear(p,m) ((p) &= ~(m))
#define bit_flip(p,m) ((p) ^= (m))
#define bit_write(c,p,m) (c ? bit_set(p,m) : bit_clear(p,m))
#define BIT(x) (0x01 << (x))
#define LONGBIT(x) ((unsigned long)0x00000001 << (x))

#define CHAR_BIT 8
#define BITMASK(b) (1 << ((b) % CHAR_BIT))
#define BITSLOT(b) ((b) / CHAR_BIT)
#define BITSET(a, b) ((a)[BITSLOT(b)] |= BITMASK(b))
#define BITCLEAR(a, b) ((a)[BITSLOT(b)] &= ~BITMASK(b))
#define BITTEST(a, b) ((a)[BITSLOT(b)] & BITMASK(b))
#define BITNSLOTS(nb) ((nb + CHAR_BIT - 1) / CHAR_BIT)

#define CMD_SHIFTLEFT 0xAA
#define CMD_ALLZEROES 0x0F
#define CMD_SETFIRSTBIT 0x01
#define CMD_GETSETBITPOSITION 0xF0

#define ProFont20Pt				20;
#define ProFont48Pt				48;

/*----------------------CONSTANTS-------------------------------*/
#define MAX_TEST_POINTS			32
#define NUM_BYTES               4;
//FUSES = {0xAF, 0xC3, 0xFF};	/* Fuse values: Low, High, Ext */
/* This is the fuse settings for this project. The fuse data will be output into the
 hex file with program code. However some flash programmers may not support this
 sort of hex files. If it is the case, use these values to program the fuse bits.
 */

DWORD AccSize; /* Work register for fs command */
WORD AccFiles, AccDirs;
FILINFO Finfo;
#if _USE_LFN
char Lfname[_MAX_LFN+1];
#endif

char Line[100]; /* Console input buffer */

FATFS Fatfs[_VOLUMES]; /* File system object for each logical drive */
FIL File[2]; /* File object */

BYTE Buff[2048]; /* Working buffer */

volatile WORD Timer; /* 100Hz increment timer */

#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1}};
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/

ISR(TIMER2_COMPB_vect) {
	Timer++; /* Performance counter for this module */
	disk_timerproc(); /* Drive timer procedure of low level disk I/O module */
}

/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */

DWORD get_fattime(void) {
#ifdef RTC_DEFINED
	RTC rtc;

	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
#else
	return 0;
#endif
}

#define MAX_QTY 5
#define MAX_FNAME_LENGTH 15

CH_RESULT startup(uint8_t *sys_board_count,uint8_t *sys_board_sequence);
CH_RESULT checkHarness(uint8_t board_count);
void displayFileList(char *ext, uint8_t length, uint8_t selected_item);
uint8_t returnFileList(char file_names[MAX_QTY][MAX_FNAME_LENGTH], char extension[]);
void drawFileList(char file_names[MAX_QTY][MAX_FNAME_LENGTH], uint8_t file_count, uint8_t selected_item);

const uint8_t MN100[] = "About";
const uint8_t MN200[] = "Configure Checker";
const uint8_t MN300[] = "Self Learn";
const uint8_t MN400[] = "Self Diagnostic";
const uint8_t MN500[] = "Output LED Sequence";
const uint8_t MN600[] = "Erase Checker";
const uint8_t MN700[] = "Copy EEPROM To SD Card";
const uint8_t MN800[] = "Hardware Test";


const uint8_t *MENU[] = {
		MN100,
		MN200,
		MN300,
		MN400,
		MN500,
		MN600,
		MN700,
		MN800
};

const uint8_t menu_count = 7;

void configureChecker(void);
void selfLearn(void);
void selfDiagnostic(void);
void about(void);
void eraseChecker(void);
void LEDSequence(void);
void copyEEPROMToSDCard(void);
void hardwareTest(void);

typedef void(*FuncPtr)(void);

const FuncPtr FuncPtrTable[] = {
		about,
		configureChecker,
		selfLearn,
		selfDiagnostic,
		LEDSequence,
		eraseChecker,
		copyEEPROMToSDCard,
		hardwareTest
};

struct Menu_State{
	uint8_t menuNo;//1,2,3,4
	uint8_t subMenuNo;//1,2,3
}MN;

enum state {ST_STARTUP, ST_IDLE, ST_CHECK, ST_STARTUP_FAULT, ST_PROGRAM, ST_COPYTOEEPROM, ST_SHOWMENU, ST_WAIT_MENU_INPUT, ST_TEST};

int main(void)
{
	// GitHub Rocks!
	FATFS FileSystemObject;
	enum state current_state = ST_STARTUP;
	uint8_t check;
	uint8_t board_count, sys_board_sequence;
	uint8_t hardware_fault = 0;
	//	CH_RESULT checkResult = CH_OK;
	CH_RESULT startupResult; CH_KEY keyPressed = 0;
	DDRG |= (0 << PG1);
	DDRG |= (1 << PG4);
	DDRB |= (0 << PB6);
	DDRA = 0x00;
	//	char str[10];

	uint8_t config_jumper;
	uint8_t boardSeq;

	int i;

	MN.menuNo = 0;
	uint8_t driver;

	driver = 0;

	char intstr[10];

	while(1)
	{
		switch (current_state)
		{
		case ST_STARTUP:
			startupResult = startup(&board_count,&sys_board_sequence);

			if (f_mount(0, &FileSystemObject) != FR_OK) {
				//return (0);
			}

			initSPI();
			uint8_t inited_boards = detectedCPLDs();
			itoa(inited_boards,intstr,10);
			GLCD_SetCursorAddress(80 + 5);
			GLCD_WriteText(intstr);

			if(startupResult == CH_INVALID_BOARD_SEQUENCE)
			{
				current_state = ST_STARTUP_FAULT;
			}
			else if(startupResult == CH_OK)
			{
				displayMessage("CHECKER READY.");
				current_state = ST_IDLE;
			}
			break;
		case ST_STARTUP_FAULT:
			displayMessage("HARDWARE FAULT.");
			hardware_fault = 1;
			current_state = ST_IDLE;
			break;
		case ST_IDLE:
			config_jumper = (PINB & (1 << PB6));
			if(config_jumper == 0)
			{
				current_state = ST_SHOWMENU;
			}

			if(!hardware_fault)
			{
				check = (PING & (1 << PG1));
				//check = 0;

				if(check == 0)
				{
					current_state = ST_CHECK;
				}
			}

			break;
		case ST_PROGRAM:
			displayMessage("PROG. MODE");
			initalizeDriverCPLDs(&board_count,&boardSeq);
			if(programHarness(board_count,boardSeq) == CH_OK)
			{
				displayMessage("LEARNED");
			}
			else
			{
				displayMessage("FAIL");
			}
			_delay_ms(3000);
			current_state = ST_IDLE;
			break;
		case ST_COPYTOEEPROM:
			GLCD_ClearGraphic();
			GLCD_ClearText();

			eepromRemoveProtectionFromAllSectors();
			while(eepromWriteInProgress())
			{
				// wait.
			}
			uint8_t status_reg = eepromReadStatusRegister();
			if((status_reg & 0x00) == 0x00)
			{
				GLCD_SetCursorAddress(0);
				GLCD_WriteText("EEPROM Write Protection Disabled.");
				GLCD_SetCursorAddress(40);
				GLCD_WriteText("Erasing EEPROM Contents...");
				GLCD_SetCursorAddress(80);

				eepromChipErase();
				if(isEEPROMErased() != CH_OK)
				{
					GLCD_WriteText("Unable to erase EEPROM contents.");
				}
				else
				{
					GLCD_WriteText("EEPROM Erased.");
					if(copyCKTFileToEEPROM("") == CH_OK)
					{
						GLCD_SetCursorAddress(120);
						GLCD_WriteText("CKT file copied.");
						if(verifyCKTFile("") == CH_OK)
						{
							GLCD_SetCursorAddress(160);
							GLCD_WriteText("CKT file verified.");

							if(copyLOCFileToEEPROM("") == CH_OK)
							{
								GLCD_SetCursorAddress(200);
								GLCD_WriteText("LOC file copied.");
								if(verifyLOCFile("") == CH_OK)
								{
									GLCD_SetCursorAddress(240);
									GLCD_WriteText("LOC file verified.");
								}
							}
						}
					}
				}

			}
			eepromWriteProtectAllSectors();
			status_reg = eepromReadStatusRegister();
			_delay_ms(3000); // this delay is essential because the input switches stay high for some time.
			if(status_reg && 0x0C)
			{
				GLCD_SetCursorAddress(280);
				GLCD_WriteText("EEPROM Write Protection Enabled.");
				GLCD_SetCursorAddress(320);
				GLCD_WriteText("Checker configuration completed.");
			}
			current_state = ST_IDLE;

			break;
		case ST_CHECK:
			displayMessage("CHECKING");
			checkHarness(board_count);
			current_state = ST_IDLE;

			break;
		case ST_SHOWMENU:
			GLCD_ClearGraphic();
			GLCD_ClearText();
			GLCD_SetCursorAddress(34);
			GLCD_WriteText(VERSION_STR);
			for(i=0;i<=menu_count;i++)
			{
				GLCD_SetCursorAddress(50+i*40);
				GLCD_WriteText((char*)MENU[i]);
			}

			GLCD_SetCursorAddress(45+MN.menuNo*40);
			GLCD_WriteText("*");
			current_state = ST_WAIT_MENU_INPUT;
			GLCD_SetCursorAddress(5000);
			//MAKECURSORINVISBLE;
			break;

		case ST_WAIT_MENU_INPUT:
			keyPressed = readKeys();

			if(keyPressed == CH_UP)
			{
				if(MN.menuNo == 0)
				{
					MN.menuNo = menu_count;
				}
				else
				{
					MN.menuNo--;
				}
				current_state = ST_SHOWMENU;
			}

			if(keyPressed == CH_DOWN)
			{
				if(MN.menuNo < menu_count)
				{
					MN.menuNo++;
				}
				else
				{
					MN.menuNo = 0;
				}
				current_state = ST_SHOWMENU;
			}

			if(keyPressed == CH_ENTER)
			{
				FuncPtrTable[MN.menuNo]();
				current_state = ST_SHOWMENU;
			}

			config_jumper = (PINB & (1 << PB6));
			if(config_jumper != 0)
			{
				GLCD_ClearGraphic();
				GLCD_ClearText();
				current_state = ST_IDLE;
			}

			break;
		}
	}

	return 0;
}

void hardwareTest(void)
{

	GLCD_ClearText(); GLCD_ClearGraphic();
	// Test SD Card

	FIL f_test; char read_buffer[400];


	GLCD_SetCursorAddress(0); GLCD_WriteText("Testing SD/MMC Card...");
	GLCD_SetCursorAddress(40);
	GLCD_WriteText("Opening file TEST.TXT");
	if(f_open(&f_test,"/TEST.TXT",FA_READ | FA_WRITE | FA_OPEN_ALWAYS) != FR_OK)
	{
		GLCD_SetCursorAddress(80);
		GLCD_WriteText("Unable to open file.");
		return;
	}
	else
	{
		GLCD_SetCursorAddress(80);
		GLCD_WriteText("File opened successfully.");
	}


	GLCD_SetCursorAddress(120);
	GLCD_WriteText("Writing...");
	UINT bytes_written, bytesRead;
	char line[4] = "BEL";
	for(int i=0;i<100;i++)
	{
		f_write(&f_test,line,sizeof(line),&bytes_written);
	}

	f_close(&f_test);

	if(f_open(&f_test,"/TEST.TXT",FA_READ | FA_WRITE | FA_OPEN_ALWAYS) != FR_OK)
	{
		return;
	}

	GLCD_SetCursorAddress(160);
	GLCD_WriteText("Reading...");
	if(f_read(&f_test,read_buffer,sizeof(read_buffer),&bytesRead)!=FR_OK)
	{
		return;
	}

	GLCD_SetCursorAddress(200);
	GLCD_WriteText("SD/MMC Card Test PASSED.");
	for(int i=0;i<100;i++)
	{
		if(read_buffer[i]!='B' || read_buffer[i+1]!='E' || read_buffer[i+2]!='L')
		{
			GLCD_WriteText("SD/MMC Card Test FAILED.");
		}
		i=i+3;
	}


	_delay_ms(10000);



	// Test EEPROM

	//	GLCD_ClearText(); GLCD_ClearGraphic();
	//	GLCD_SetCursorAddress(0);
	//	GLCD_WriteText("Testing EEPROM...");
	//	uint8_t buffer[EEPROM_PAGESIZE]; uint16_t address = 0;
	//	char read_buffer[EEPROM_PAGESIZE];
	//	for(int i = 0; i < EEPROM_PAGESIZE; i++)
	//	{
	//		buffer[i] = 0xAA;
	//	}
	//	eepromRemoveProtectionFromAllSectors();
	//	while(eepromWriteInProgress())
	//	{
	//		// wait.
	//	}
	//	uint8_t status_reg = eepromReadStatusRegister();
	//
	//	if((status_reg & 0x00) == 0x00)
	//	{
	//		GLCD_SetCursorAddress(40);
	//		GLCD_WriteText("EEPROM Write Protection Disabled.");
	//	}
	//	else
	//	{
	//		return; //fail.
	//	}
	//
	//	for(int i=0;i<(EEPROM_SIZE/EEPROM_PAGESIZE);i++)
	//	{
	//		eepromWritePage(buffer,address);
	//		address = address + EEPROM_PAGESIZE;
	//		while(eepromWriteInProgress())
	//		{
	//			// wait.
	//		}
	//	}
	//
	//	//-- writing complete
	//
	//	uint8_t test_passed = 1; address = 0;
	//	for(int i = 0; i<(EEPROM_SIZE/EEPROM_PAGESIZE);i++)
	//	{
	//		eepromRead(read_buffer,address,EEPROM_PAGESIZE);
	//		for(int j=0;j<EEPROM_PAGESIZE;j++)
	//		{
	//			if(read_buffer[j] != 0xAA)
	//			{
	//				test_passed = 0;
	//				break;
	//			}
	//		}
	//		address = address + EEPROM_PAGESIZE;
	//	}
	//
	//	if(test_passed)
	//	{
	//		GLCD_SetCursorAddress(80);
	//		GLCD_WriteText("EEPROM TEST PASS.");
	//	}
	//
	//	GLCD_SetCursorAddress(120);
	//	GLCD_WriteText("Finished");
	//	_delay_ms(100000);

}

CH_RESULT startup(uint8_t *sys_board_count, uint8_t *sys_board_sequence)
{
	GLCD_Initialize();

	setupSPIPorts();
	DDRG |= (1 << PG4); PORTG |= (1 << PG4);
	//	PORTG &= ~(1 << PG4);



	initSPI();
	uint8_t board_count;
	uint8_t boardSeq;
	initalizeDriverCPLDs(&board_count,&boardSeq);
	uint8_t storedBoardSeq = returnStoredBoardSequence();

	if(checkBoardSequence(boardSeq) != CH_OK)
	{
		return CH_INVALID_BOARD_SEQUENCE;
	}
	*sys_board_count = board_count;

	if(boardSeq != storedBoardSeq)
	{
		return CH_INVALID_BOARD_SEQUENCE;
	}
	*sys_board_sequence = storedBoardSeq;

	return CH_OK;
}

CH_RESULT checkHarness(uint8_t board_count)
{
	WireInfo faulty_wires[7];
	uint16_t fault_count;
	CH_RESULT result = findFaultsAndReturnFaultyWireInfos(board_count, faulty_wires, &fault_count);
	if(result!=CH_OK)
	{
		if(result == CH_WRONG_SLOT)
		{
			char fault_type[14] = "WRONG SLOT";
			displayFaults(faulty_wires,fault_type,fault_count);
		}
		else if(result == CH_MISSING_WIRE)
		{
			char fault_type[14] = "MISSING WIRE";
			displayFaults(faulty_wires,fault_type,fault_count);
		}
		else if(result == CH_SHORT_CIRCUIT)
		{
			char fault_type[14] = "SHORT CIRCUIT";
			displayFaults(faulty_wires,fault_type,fault_count);
		}
	}
	else if(result == CH_OK)
	{
		displayOKScreen();
		_delay_ms(1000);
		displayMessage("CONNECT HARNESS");
	}
	return result;
}

void configureChecker(void)
{
	uint8_t selected_file_index = 0;
	char file_names[MAX_QTY][MAX_FNAME_LENGTH];
	char chk_file_path[MAX_FNAME_LENGTH+5] = {'\0'};
	char loc_file_path[MAX_FNAME_LENGTH+5] = {'\0'};

	GLCD_ClearText(); GLCD_ClearGraphic();
	uint8_t file_count = returnFileList(file_names,"CHK");

	drawFileList(file_names,file_count,0);

	while(1)
	{
		if(readKeys() == CH_DOWN)
		{
			selected_file_index++;
			if(selected_file_index>1)
			{
				selected_file_index=0;
			}
			drawFileList(file_names,file_count,selected_file_index);
			GLCD_SetCursorAddress(80+15);
			GLCD_WriteText("Choose CHK File...");
		}

		if(readKeys() == CH_ENTER)
		{
			strncpy(chk_file_path,"/",1);
			strncat(chk_file_path,file_names[selected_file_index],strlen(file_names[selected_file_index]));
			break;
		}
	}

	GLCD_ClearText();

	file_count = returnFileList(file_names,"LOC");
	drawFileList(file_names,file_count,0);
	selected_file_index = 0;

	while(1)
	{
		if(readKeys() == CH_DOWN)
		{
			selected_file_index++;
			if(selected_file_index>1)
			{
				selected_file_index=0;
			}
			drawFileList(file_names,file_count,selected_file_index);
			GLCD_SetCursorAddress(80+15);
			GLCD_WriteText("Choose LOC File...");
		}

		if(readKeys() == CH_ENTER)
		{
			strncpy(loc_file_path,"/",1);
			strncat(loc_file_path,file_names[selected_file_index],strlen(file_names[selected_file_index]));
			break;
		}
	}

	//	GLCD_SetCursorAddress(400);
	//	GLCD_WriteText(chk_file_path);
	//
	//
	//
	//	while(1)
	//	{
	//		i++;
	//	}




	//	address = 0; GLCD_SetCursorAddress(address);
	//	GLCD_WriteText("This option will erase all contents of the Checker.");
	//
	//	GLCD_WriteText("");
	//	address += 40; GLCD_SetCursorAddress(address);
	//	GLCD_WriteText("Press OK to continue and Cancel to return to menu.");

	//	while(1)
	//	{
	//		up = (PINA & (1 << PA3));
	//		down = (PINA & (1 << PA2));
	//		if(up == 8)
	//		{
	//			_delay_ms(2000);
	//			break;
	//		}
	//		if(down == 4)
	//		{
	//			_delay_ms(2000);
	//			return;
	//		}
	//	}

	GLCD_ClearText();
	GLCD_SetCursorAddress(0);
	GLCD_WriteText("CKT File: ");
	GLCD_WriteText(chk_file_path);
	GLCD_SetCursorAddress(40);
	GLCD_WriteText("LOC File: ");
	GLCD_WriteText(loc_file_path);
	eepromRemoveProtectionFromAllSectors();
	while(eepromWriteInProgress())
	{
		// wait.
	}
	uint8_t status_reg = eepromReadStatusRegister();
	if((status_reg & 0x00) == 0x00)
	{
		GLCD_SetCursorAddress(80);
		GLCD_WriteText("EEPROM Write Protection Disabled.");
		GLCD_SetCursorAddress(120);
		GLCD_WriteText("Erasing EEPROM Contents...");
		GLCD_SetCursorAddress(160);

		eepromChipErase();
		if(isEEPROMErased() != CH_OK)
		{
			GLCD_WriteText("Unable to erase EEPROM contents.");
		}
		else
		{
			GLCD_WriteText("EEPROM Erased.");
			if(copyCKTFileToEEPROM(chk_file_path) == CH_OK)
			{
				GLCD_SetCursorAddress(200);
				GLCD_WriteText("CKT file copied.");
				if(verifyCKTFile(chk_file_path) == CH_OK)
				{
					GLCD_SetCursorAddress(240);
					GLCD_WriteText("CKT file verified.");

					if(copyLOCFileToEEPROM(loc_file_path) == CH_OK)
					{
						GLCD_SetCursorAddress(280);
						GLCD_WriteText("LOC file copied.");
						if(verifyLOCFile(loc_file_path) == CH_OK)
						{
							GLCD_SetCursorAddress(320);
							GLCD_WriteText("LOC file verified.");
						}
					}
				}
			}
		}

	}
	eepromWriteProtectAllSectors();
	status_reg = eepromReadStatusRegister();

	if(status_reg && 0x0C)
	{
		GLCD_SetCursorAddress(360);
		GLCD_WriteText("EEPROM Write Protection Enabled.");
		GLCD_SetCursorAddress(400);
		GLCD_WriteText("Checker configuration completed.");
	}
	while(readKeys() != CH_CANCEL);
}
void selfLearn(void)
{
	uint8_t board_count, boardSeq;
	displayMessage("PROG. MODE");
	initalizeDriverCPLDs(&board_count,&boardSeq);
	if(programHarness(board_count,boardSeq) == CH_OK)
	{
		displayMessage("LEARNED");
	}
	else
	{
		displayMessage("FAIL");
	}
	while(readKeys() != CH_CANCEL);
}
void selfDiagnostic(void)
{

}
void about(void)
{
	GLCD_ClearGraphic();
	GLCD_ClearText();

	char ckt_header[CKT_HEADER_LENGTH];
	char loc_header[LOC_HEADER_LENGTH];
	eepromRead(ckt_header,CKT_HEADER_ADDR,CKT_HEADER_LENGTH);
	eepromRead(loc_header,LOC_HEADER_ADDR,LOC_HEADER_LENGTH);

	uint8_t ckt_ok = 0, loc_ok = 0;

	GLCD_SetCursorAddress(0);
	if(ckt_header[0] == 'C' && ckt_header[1] == 'K' && ckt_header[2] == 'T')
	{
		ckt_ok = 1;
	}

	if(loc_header[0] == 'L' && loc_header[1] == 'O' && loc_header[2] == 'C')
	{
		loc_ok = 1;
	}

	drawText("CHECKER INFO", 13, 320/2 - textWidthOfString("CHECKER INFO",20)/2, 20, 20);

	uint16_t line_address = 280;
	const uint8_t newline = 40;

	GLCD_SetCursorAddress(line_address+5);

	if(loc_ok & ckt_ok)
	{
		char *harness_name = loc_header+3;
		GLCD_WriteText("Harness: ");
		GLCD_WriteText(harness_name);
		line_address+=newline;

		GLCD_SetCursorAddress(line_address + 5);
		GLCD_WriteText("Wire Count: ");
		GLCD_WriteText("248");
		line_address+=(newline*2);

		GLCD_SetCursorAddress(line_address + 5);
		GLCD_WriteText("Checker Activation Date: ");
		GLCD_WriteText("31/10/12");

		line_address+=newline;
		GLCD_SetCursorAddress(line_address + 5);
		GLCD_WriteText("Serial Number: ");
		GLCD_WriteText("0623414");

		line_address+=(newline*2);
	}
	else
	{
		GLCD_WriteText("Checker Config. Data Not Found.");
		line_address+=(newline*6);
	}

	char intstr[3];
	uint8_t inited_boards = detectedCPLDs();
	GLCD_SetCursorAddress(line_address + 5);
	GLCD_WriteText("Board IO Status:");


	for(int i=0;i<MAX_DAUGHTER_BOARDS;i++)
	{
		line_address+=(newline);
		GLCD_SetCursorAddress(line_address + 5);
		if(i==0)
		{
			GLCD_WriteText("Controller Board ");
		}
		else
		{
			GLCD_WriteText("Daughter Board: ");
		}

		itoa(i,intstr,10);
		GLCD_WriteText(intstr);
		if(inited_boards & (1 << i))
		{
			GLCD_WriteText(": OK.");
		}
		else
		{
			GLCD_WriteText(": Not Detected.");
		}
	}


	line_address+=(newline*4);
	GLCD_SetCursorAddress(line_address + 5);
	GLCD_WriteText("Press OK to return to menu.");

	while(readKeys() != CH_CANCEL);
}
void eraseChecker(void)
{
	GLCD_ClearGraphic();
	GLCD_ClearText();
	GLCD_SetCursorAddress(85);

	GLCD_WriteText("This will erase the contents of the internal EEPROM.");
	GLCD_SetCursorAddress(85+40);
	GLCD_WriteText("Are you sure you want to continue?");

	_delay_ms(5000);
	while((PINA & (1 << PA3)) == 0);
	_delay_ms(3000);

}

void copyEEPROMToSDCard(void)
{
	GLCD_ClearText();
	GLCD_ClearGraphic();
	GLCD_SetCursorAddress(0);
	copyEEPROMToFile();
	GLCD_WriteText("DONE");
	_delay_ms(3000);
}

void LEDSequence(void)
{
	char str[3];

	GLCD_ClearGraphic();
	GLCD_ClearText();
	GLCD_SetCursorAddress(0);
	GLCD_WriteText("Outputting LED Sequence...");
	uint8_t driver = 4;
	uint8_t wire;
	while(1)
	{
		setFirstBitOnDriver(driver);
		GLCD_SetCursorAddress(40);
		GLCD_WriteText("LED: ");
		for(wire=0;wire<72;wire++)
		{
			itoa(wire+1,str,10);
			GLCD_WriteText(str);
			GLCD_SetCursorAddress(44);
			//_delay_ms(400);
			shiftVectorOnDriver(driver);
			if(readKeys() == CH_CANCEL)
			{
				return;
			}
		}
	}
}

uint8_t returnFileList(char file_names[MAX_QTY][MAX_FNAME_LENGTH], char extension[])
{
	FRESULT res;
	DIR dir;
	FILINFO fno;

	char complete_filename[13];
	char *file_name;
	char *file_extension;
	uint8_t i=0;

	res = f_opendir(&dir,"/");
	if (res == FR_OK)
	{
		do // CONVERT THIS LOOP TO A FOR LOOP WITH MAX ITERATIONS TO MAX_QTY
		{
			res = f_readdir(&dir,&fno);
			if(res == FR_OK)
			{
				if(!(fno.fattrib & AM_DIR))
				{
					strcpy(complete_filename,fno.fname);
					file_name = strtok(complete_filename, ".");
					file_extension = strtok(NULL, ".");

					if(!strcmp(extension,file_extension))
					{
						strcpy(file_names[i],fno.fname);
						i++;
					}
				}
			}
		}while(fno.fname[0] != 0x00);
	}
	return i;
}

void drawFileList(char file_names[MAX_QTY][MAX_FNAME_LENGTH], uint8_t file_count, uint8_t selected_item)
{
	int i = 3;

	GLCD_ClearText();GLCD_ClearGraphic();
	GLCD_SetCursorAddress(40+5);
	for(i=0;i<file_count;i++)
	{
		GLCD_SetCursorAddress(120+15 +i*40);
		GLCD_WriteText(file_names[i]);
	}

	GLCD_SetCursorAddress((3+selected_item)*40+12);
	GLCD_WriteText("*");
}
void displayFileList(char *ext, uint8_t length, uint8_t selected_item)
{
	GLCD_ClearGraphic();
	GLCD_ClearText();

	int i = 3;
	FRESULT res;
	DIR dir;
	FILINFO fno;
	char complete_file_name[13];
	char *file_name; char *extension;


	GLCD_SetCursorAddress(40+5);
	//GLCD_WriteText("Choose CHK File...");
	res = f_opendir(&dir,"/");
	if (res == FR_OK)
	{
		do
		{
			res = f_readdir(&dir,&fno);
			if(res == FR_OK)
			{
				GLCD_SetCursorAddress(i*40 + 15);
				if(!(fno.fattrib & AM_DIR))
				{
					strcpy(complete_file_name,fno.fname);
					file_name = strtok(complete_file_name, ".");
					extension = strtok(NULL, ".");

					if(!strcmp(extension,ext))
					{
						GLCD_WriteText(fno.fname);
						i++;
					}
				}
			}

		}while(fno.fname[0] != 0x00);
	}

	GLCD_SetCursorAddress((3+selected_item)*40 + 12);
	GLCD_WriteText("*");
}

