/*----------------------------------------------------------------------------/
	/  Checker Firmware v0.13                  (C)Bahawalpur Engineering Ltd, 2012
	/----------------------------------------------------------------------------*/
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include "uart.h"
#include "xitoa.h"
#include "ff.h"
#include "diskio.h"
#include "rtc.h"
#include "sed1335.h"
#include "25LC512.h"
#include "constants.h"
#include "harnessio.h"

#define bit_get(p,m) ((p) & (m))
#define bit_set(p,m) ((p) |= (m))
#define bit_clear(p,m) ((p) &= ~(m))
#define bit_flip(p,m) ((p) ^= (m))
#define bit_write(c,p,m) (c ? bit_set(p,m) : bit_clear(p,m))
#define BIT(x) (0x01 << (x))
#define LONGBIT(x) ((unsigned long)0x00000001 << (x))

#define CHAR_BIT 8
#define BITMASK(b) (1 << ((b) % CHAR_BIT))
#define BITSLOT(b) ((b) / CHAR_BIT)
#define BITSET(a, b) ((a)[BITSLOT(b)] |= BITMASK(b))
#define BITCLEAR(a, b) ((a)[BITSLOT(b)] &= ~BITMASK(b))
#define BITTEST(a, b) ((a)[BITSLOT(b)] & BITMASK(b))
#define BITNSLOTS(nb) ((nb + CHAR_BIT - 1) / CHAR_BIT)

#define CMD_SHIFTLEFT 0xAA
#define CMD_ALLZEROES 0x0F
#define CMD_SETFIRSTBIT 0x01
#define CMD_GETSETBITPOSITION 0xF0

#define ProFont20Pt				20;
#define ProFont48Pt				48;

/*----------------------CONSTANTS-------------------------------*/
#define MAX_TEST_POINTS			32
#define NUM_BYTES               4;
//FUSES = {0xAF, 0xC3, 0xFF};	/* Fuse values: Low, High, Ext */
/* This is the fuse settings for this project. The fuse data will be output into the
	hex file with program code. However some flash programmers may not support this
	sort of hex files. If it is the case, use these values to program the fuse bits.
 */


DWORD AccSize;				/* Work register for fs command */
WORD AccFiles, AccDirs;
FILINFO Finfo;
#if _USE_LFN
char Lfname[_MAX_LFN+1];
#endif


char Line[100];				/* Console input buffer */

FATFS Fatfs[_VOLUMES];		/* File system object for each logical drive */
FIL File[2];				/* File object */

BYTE Buff[2048];			/* Working buffer */

volatile WORD Timer;		/* 100Hz increment timer */



#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1} };
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/


ISR(TIMER2_COMP_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}



/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */


DWORD get_fattime (void)
{
#ifdef RTC_DEFINED
	RTC rtc;

	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
#else
	return	0;
#endif
}



void chipSelect(uint8_t chipID)
{
	PORTE = 0xFF;
	bit_set(PORTB,BIT(7));
	bit_set(PORTF,BIT(1));
	bit_set(PORTG,BIT(5));
	bit_set(PORTB,BIT(0));


	if(chipID == B0_Driver) // Select Driver
	{
		bit_clear(PORTF,BIT(1));
	}
	else if(chipID == B0_Rcv) // Select Receiver
	{
		bit_clear(PORTB,BIT(7));
	}
	else if(chipID == EEPROM)
	{
		bit_clear(PORTG,BIT(5));
	}
	else if(chipID == B1_Driver)
	{
		bit_clear(PORTE,BIT(6));
	}
}

void setupSPI(void)
{
	SPCR = (1 << SPE) | (1 << MSTR) | (0 << CPHA) | (0 << CPOL) | (0 << SPR1) | (0 << SPR0);
	SPSR = (0 << SPI2X);
	_delay_us(1);
}


void setupSPIPorts(void)
{
	PORTB = 0b11111101;
	DDRB = (MOSI) | (SCK) | (B0_Rcv) | (SDCard);


	DDRE = 0xFF;
	PORTE = 0xFF;

	DDRG = (1 << PG5);
	bit_set(PORTG,5); // EEPROM

	chipSelect(DESELECT);
}


uint8_t readByte(void)
{
	uint8_t byteFromSlave;
	SPDR = 0xFF;
	while(!(SPSR & (1 << SPIF)));
	byteFromSlave = SPDR;
	return byteFromSlave;
}

void sendByte(uint8_t byteToSend)
{
	uint8_t byteFromSlave;
	SPDR = byteToSend;
	while(!(SPSR & (1 << SPIF)));
	byteFromSlave = SPDR;
}

void writeEnable(void)
{
	uint8_t WREN = 0x06;

	chipSelect(EEPROM);
	sendByte(WREN);
	chipSelect(DESELECT);
}

void writeBuffer(uint8_t buffer[], uint16_t address)
{
	const uint8_t WRITE = 0x02;

	writeEnable();

	chipSelect(EEPROM);
	sendByte(WRITE);

	sendByte(address >> 8);
	sendByte(address);

	for(int i = 0;i < 128;i++)
	{
		sendByte(buffer[i]);
	}
	chipSelect(DESELECT);
	_delay_ms(10);
}

void eeprom_write()
{

	const uint8_t WRITE = 0x02;

	writeEnable();

	_delay_us(1);

	chipSelect(EEPROM);
	sendByte(WRITE);

	uint16_t address = 0;

	sendByte(address >> 8);
	sendByte(address);

	for(int i = 0; i<128; i++)
	{
		sendByte(42);
	}
	chipSelect(DESELECT);
	_delay_ms(10);
}

void eeprom_read()
{
	const uint8_t READ = 0x03;

	char str[10];
	for(int i = 0;i<10;i++)
	{
		str[i] = 0x00;
	}


	uint16_t address = 33360;

	chipSelect(EEPROM);
	sendByte(READ);
	eepromSendAddress(address);

	for(int i = 0;i<5;i++)
	{
		str[i] = readByte();
	}

	GLCD_WriteText(str);
	chipSelect(DESELECT);
}

int main(void)
{
	FATFS FileSystemObject;
	GLCD_Initialize();

	setupSPIPorts();

	uint8_t eeprom_buffer[128];

	if(f_mount(0,&FileSystemObject)!=FR_OK)
	{
		return 0;
	}

	setupSPI();

	FIL f_harness;
	if(f_open(&f_harness,"/data.bin",FA_READ | FA_WRITE | FA_OPEN_ALWAYS) != FR_OK)
	{
		GLCD_SetCursorAddress(0);
		GLCD_WriteText("Cannot Open File.");
		return 0;
	}
	unsigned int bytesRead;
	uint16_t address = 32768;

	/*do
	{
		if(f_read(&f_harness,eeprom_buffer,128,&bytesRead)!=FR_OK)
		{
			GLCD_SetCursorAddress(0);
			GLCD_WriteText("Cannot Read File");
			return 0;
		}
		writeBuffer(eeprom_buffer,address);
		address = address + 128;
	}while(bytesRead == 128);

	f_close(&f_harness);
	f_mount(0,0);*/


	DDRF = (1 << PF0);
	bit_set(PORTF,BIT(0));

	_delay_us(1);

	char my_str[10];

	WireInfo info;
	WireInfo wires[7];

	//	for(int i=0;i<72;i++)
	//	{
	//		readWireParameters(i,&info);
	//		GLCD_SetCursorAddress(0);
	//		GLCD_WriteText(info.locationA);
	//		GLCD_SetCursorAddress(10);
	//		GLCD_WriteText(info.locationB);
	//		GLCD_SetCursorAddress(20);
	//		GLCD_WriteText(info.colour);
	//		GLCD_SetCursorAddress(30);
	//		GLCD_WriteText(info.gauge);
	//		_delay_ms(1000);
	//	}

	//		if(copyHarnessCircuitData() == 0)
	//		{
	//			GLCD_SetCursorAddress(0);
	//			GLCD_WriteText("Copy Success");
	//		}

	char my_buf[128];
	eepromRead(my_buf,646,4);

	itoa(my_buf[0],my_str,10);
	GLCD_SetCursorAddress(40);
	GLCD_WriteText(my_str);

	itoa(my_buf[1],my_str,10);
	GLCD_SetCursorAddress(80);
	GLCD_WriteText(my_str);

	itoa(my_buf[2],my_str,10);
	GLCD_SetCursorAddress(120);
	GLCD_WriteText(my_str);

	itoa(my_buf[3],my_str,10);
	GLCD_SetCursorAddress(160);
	GLCD_WriteText(my_str);

	if(verifyHarnessCircuitData() == 0)
	{
		GLCD_SetCursorAddress(0);
		GLCD_WriteText("Verification Successful.");
	}

	// uint16_t wire_pos[6] = {0,1,10,50,2,20};
	// 
	// 	readWireParametersFromIndices(wire_pos,wires);
	// 

	// 	for(int i=0;i<3;i++)
	// 	{

	// 		GLCD_SetCursorAddress(0);
	// 				GLCD_WriteText(wires[i].locationA);
	// 				GLCD_SetCursorAddress(10);
	// 				GLCD_WriteText(wires[i].locationB);
	// 				GLCD_SetCursorAddress(20);
	// 				GLCD_WriteText(wires[i].colour);
	// 				GLCD_SetCursorAddress(30);
	// 				GLCD_WriteText(wires[i].gauge);
	// 		_delay_ms(1000);
	// 	}

	return 0;
}
