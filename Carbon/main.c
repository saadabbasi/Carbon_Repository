#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include "uart.h"
#include "xitoa.h"
#include "ff.h"
#include "diskio.h"
#include "rtc.h"
#include "sed1335.h"
#include "25LC512.h"
#include "constants.h"
#include "SPIController.h"
#include "CPLD_API.h"
#include "CheckerAPI.h"
#include "display.h"

#define bit_get(p,m) ((p) & (m))
#define bit_set(p,m) ((p) |= (m))
#define bit_clear(p,m) ((p) &= ~(m))
#define bit_flip(p,m) ((p) ^= (m))
#define bit_write(c,p,m) (c ? bit_set(p,m) : bit_clear(p,m))
#define BIT(x) (0x01 << (x))
#define LONGBIT(x) ((unsigned long)0x00000001 << (x))

#define CHAR_BIT 8
#define BITMASK(b) (1 << ((b) % CHAR_BIT))
#define BITSLOT(b) ((b) / CHAR_BIT)
#define BITSET(a, b) ((a)[BITSLOT(b)] |= BITMASK(b))
#define BITCLEAR(a, b) ((a)[BITSLOT(b)] &= ~BITMASK(b))
#define BITTEST(a, b) ((a)[BITSLOT(b)] & BITMASK(b))
#define BITNSLOTS(nb) ((nb + CHAR_BIT - 1) / CHAR_BIT)

#define CMD_SHIFTLEFT 0xAA
#define CMD_ALLZEROES 0x0F
#define CMD_SETFIRSTBIT 0x01
#define CMD_GETSETBITPOSITION 0xF0

#define ProFont20Pt				20;
#define ProFont48Pt				48;

/*----------------------CONSTANTS-------------------------------*/
#define MAX_TEST_POINTS			32
#define NUM_BYTES               4;
//FUSES = {0xAF, 0xC3, 0xFF};	/* Fuse values: Low, High, Ext */
/* This is the fuse settings for this project. The fuse data will be output into the
 hex file with program code. However some flash programmers may not support this
 sort of hex files. If it is the case, use these values to program the fuse bits.
 */

DWORD AccSize; /* Work register for fs command */
WORD AccFiles, AccDirs;
FILINFO Finfo;
#if _USE_LFN
char Lfname[_MAX_LFN+1];
#endif

char Line[100]; /* Console input buffer */

FATFS Fatfs[_VOLUMES]; /* File system object for each logical drive */
FIL File[2]; /* File object */

BYTE Buff[2048]; /* Working buffer */

volatile WORD Timer; /* 100Hz increment timer */

#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1}};
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/

ISR(TIMER2_COMP_vect) {
	Timer++; /* Performance counter for this module */
	disk_timerproc(); /* Drive timer procedure of low level disk I/O module */
}

/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */

DWORD get_fattime(void) {
#ifdef RTC_DEFINED
	RTC rtc;

	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
#else
	return 0;
#endif
}

void startup(uint8_t *sys_board_count);
CH_RESULT checkHarness(uint8_t board_count);

enum state {ST_STARTUP, ST_IDLE, ST_CHECK};

int main(void)
{
	enum state current_state = ST_STARTUP;
	enum state prev_state = ST_STARTUP;
	uint8_t check;
	uint8_t board_count;
	CH_RESULT checkResult = CH_OK;
	DDRG |= (0 << PG1);
	while(1)
	{
		switch (current_state)
		{
		case ST_STARTUP:
			startup(&board_count);
			prev_state = ST_STARTUP;
			current_state = ST_IDLE;
			break;
		case ST_IDLE:
			if(prev_state != ST_IDLE && checkResult == CH_OK)
			{
				displayMessage("CONNECT HARNESS");
			}
			check = (PING & (1 << PG1));
			if(check == 0)
			{
				current_state = ST_CHECK;
			}
			prev_state = ST_IDLE;
			break;
		case ST_CHECK:
			checkResult = checkHarness(board_count);
			prev_state = ST_CHECK;
			current_state = ST_IDLE;
			break;
		}
	}


	//	char str[10];
	//	FATFS FileSystemObject;
	//	GLCD_Initialize();
	//
	//	setupSPIPorts();
	//	DDRG |= (1 << PG4); PORTG |= (1 << PG4);
	//	//	PORTG &= ~(1 << PG4);
	//
	//	if (f_mount(0, &FileSystemObject) != FR_OK) {
	//		return (0);
	//	}
	//
	//	initSPI();
	//	uint8_t board_count;
	//	uint8_t test;
	//	initalizeDriverCPLDs(&board_count,&test);
	//	itoa(board_count,str,10);
	//
	//	GLCD_SetCursorAddress(0);
	//	GLCD_WriteText(str);
	//	//
	//	WireInfo faulty_wires[7];
	//	uint16_t fault_count;
	//	CH_RESULT result = findFaultsAndReturnFaultyWireInfos(board_count, faulty_wires, &fault_count);
	//	if(result!=CH_OK)
	//	{
	//		if(result == CH_WRONG_SLOT)
	//		{
	//			char fault_type[14] = "WRONG SLOT";
	//			displayFaults(faulty_wires,fault_type,fault_count);
	//		}
	//		else if(result == CH_MISSING_WIRE)
	//		{
	//			char fault_type[14] = "MISSING WIRE";
	//			displayFaults(faulty_wires,fault_type,fault_count);
	//		}
	//		else if(result == CH_SHORT_CIRCUIT)
	//		{
	//			char fault_type[14] = "SHORT CIRCUIT";
	//			displayFaults(faulty_wires,fault_type,fault_count);
	//		}
	//	}
	//	else if(result == CH_OK)
	//	{
	//		displayOKScreen();
	//	}

	//eepromChipErase();
	//	DDRF |= (1 << PF0);
	//	bit_set(PORTF, BIT(0));

	//	copyCKTFileToEEPROM();
	//	if(verifyCKTFile()==CH_OK)
	//	{
	//		GLCD_WriteText("CKT FILE OK!");
	//	}
	//programHarness(board_count,test);




	return 0;
}

CH_RESULT checkHarness(uint8_t board_count)
{
	WireInfo faulty_wires[7];
	uint16_t fault_count;
	CH_RESULT result = findFaultsAndReturnFaultyWireInfos(board_count, faulty_wires, &fault_count);
	if(result!=CH_OK)
	{
		if(result == CH_WRONG_SLOT)
		{
			char fault_type[14] = "WRONG SLOT";
			displayFaults(faulty_wires,fault_type,fault_count);
		}
		else if(result == CH_MISSING_WIRE)
		{
			char fault_type[14] = "MISSING WIRE";
			displayFaults(faulty_wires,fault_type,fault_count);
		}
		else if(result == CH_SHORT_CIRCUIT)
		{
			char fault_type[14] = "SHORT CIRCUIT";
			displayFaults(faulty_wires,fault_type,fault_count);
		}
	}
	else if(result == CH_OK)
	{
		displayOKScreen();
		_delay_ms(1000);
	}
	return result;
}


void startup(uint8_t *sys_board_count)
{
	FATFS FileSystemObject;
	GLCD_Initialize();

	setupSPIPorts();
	DDRG |= (1 << PG4); PORTG |= (1 << PG4);
	//	PORTG &= ~(1 << PG4);

	if (f_mount(0, &FileSystemObject) != FR_OK) {
		//return (0);
	}

	initSPI();
	uint8_t board_count;
	uint8_t boardSeq;
	initalizeDriverCPLDs(&board_count,&boardSeq);
	uint8_t storedBoardSeq = returnStoredBoardSequence();
	if(checkBoardSequence(boardSeq)==CH_OK)
	{
		if(boardSeq == storedBoardSeq)
		{
			GLCD_SetCursorAddress(0);
			GLCD_WriteText("ALL OK");
			*sys_board_count = board_count;
		}
	}
}
